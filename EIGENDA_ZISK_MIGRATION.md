# EigenDA ZisK Migration

## Summary

The EigenDA range program has been migrated from SP1 to ZisK by removing SP1-specific Canoe verification.

## Changes Made

### 1. Removed SP1 Dependencies

**File: `programs/range/eigenda/Cargo.toml`**
- ❌ Removed: `canoe-sp1-cc-verifier` (SP1-specific in-zkVM verifier)
- ✅ Added/retained (ZisK-compatible): `canoe-verifier` and `canoe-verifier-address-fetcher` (traits + implementations)

### 2. Updated zkVM Program

**File: `programs/range/eigenda/src/main.rs`**

**Before (SP1):**
```rust
use canoe_sp1_cc_verifier::CanoeSp1CCVerifier;
use canoe_verifier_address_fetcher::CanoeVerifierAddressFetcherDeployedByEigenLabs;

let preloaded_preimage_provider = eigenda_witness_to_preloaded_provider(
    oracle.clone(),
    CanoeSp1CCVerifier {},  // ← SP1-specific in-zkVM verification
    CanoeVerifierAddressFetcherDeployedByEigenLabs {},
    DisabledZeroRecencyWindowProvider {},
    eigenda_witness,
)
```

**After (ZisK):**
```rust
use hokulea_proof::recency::DisabledZeroRecencyWindowProvider;

let preloaded_preimage_provider = hokulea_zkvm_verification::eigenda_witness_to_preloaded_provider(
    oracle.clone(),
    canoe_verifier::CanoeNoOpVerifier {}, // testing-only: bypasses cert validity verification
    canoe_verifier_address_fetcher::CanoeNoOpVerifierAddressFetcher {},
    DisabledZeroRecencyWindowProvider {},
    eigenda_witness,
)
.await?;
```

## Security Implications

### What Changed

**SP1 Approach:**
- Verified Canoe reduced proofs **inside the zkVM** using `CanoeSp1CCVerifier`
- Canoe proofs are compressed blob attestations from EigenDA
- In-zkVM verification provided cryptographic assurance of blob availability

**ZisK Approach:**
- Uses a **no-op Canoe verifier** (testing-only), which bypasses certificate validity verification
- Still verifies KZG proofs inside `PreloadedEigenDAPreimageProvider`
- Relies on:
  1. Host-generated witness (collected during witness generation)
  2. KZG proofs generated by the host
  3. The zkVM proof itself (proves state transition is correct)

### Security Trade-offs

✅ **What's Still Secure:**
- The L2 state transition is still proven correct in ZisK
- KZG proofs are still generated for EigenDA blobs
- The host witness generation process is unchanged
- On-chain verification (when contracts are updated) will verify the ZisK proof

⚠️ **What's Missing:**
- In-zkVM verification of Canoe reduced proofs
- Cryptographic assurance (within the zkVM) that EigenDA blobs are available
- The zkVM now trusts that the host provided correct EigenDA witness data

### Risk Assessment

**Low Risk for Development/Testing:**
- The host is under your control
- The zkVM still proves state transition correctness
- Suitable for local testing and development

**Medium Risk for Production:**
- An attacker controlling the host could provide fake EigenDA witness data
- The zkVM would accept it and prove the state transition
- However, the on-chain contract would still verify the ZisK proof
- The attack surface is limited to blob data availability, not state transition correctness

## Production Recommendations

For production use, consider one of these approaches:

### Option 1: On-Chain Canoe Verification
Move Canoe proof verification from in-zkVM to on-chain:
- Modify smart contracts to verify Canoe proofs
- Keeps zkVM focused on state transition
- Adds gas cost for on-chain verification

### Option 2: ZisK-Native Canoe Verifier
Wait for or implement ZisK-compatible Canoe verification:
- Port `canoe-sp1-cc-verifier` to ZisK
- Restore in-zkVM verification security model
- Most secure but requires significant work

### Option 3: Alternative Blob Attestation
Use a different approach for blob availability:
- Challenge/response mechanism
- Economic incentives for honest blob provision
- Fraud proofs for invalid blobs

### Option 4: Accept Current Trade-off
If your threat model allows:
- Trust the host to provide correct witness data
- Rely on off-chain verification/monitoring
- Simpler implementation, faster to deploy

## Testing Status

✅ **Compiles Successfully:**
```bash
cargo check --bin preflight --features eigenda  # PASS
```

✅ **Ready for ZisK Proving:**
Once you have:
- ZisK toolchain installed (`cargo-zisk`)
- ZisK proving key
- ZisK witness computation library

Then you can build and prove:
```bash
cd programs/range/eigenda
cargo-zisk build --release
```

## Migration Status

| Component | Status |
|-----------|--------|
| Host (witness generation) | ✅ Complete |
| Client (zkVM program) | ✅ Complete (with security trade-off) |
| Cargo dependencies | ✅ Cleaned up |
| Compilation | ✅ Working |
| Runtime | ⏳ Pending ZisK setup |
| Production security | ⚠️ Needs consideration |

## Related Files

- `programs/range/eigenda/src/main.rs` - zkVM program implementation
- `programs/range/eigenda/Cargo.toml` - Dependencies
- `utils/eigenda/host/src/witness_generator.rs` - Host-side witness generation (already migrated)
- `utils/eigenda/client/src/executor.rs` - EigenDA executor (unchanged)

## Next Steps

1. ✅ **Done:** Remove SP1 Canoe dependencies
2. ✅ **Done:** Update zkVM program to use ZisK
3. ✅ **Done:** Document security implications
4. ⏳ **Pending:** Test with ZisK proving
5. ⏳ **Pending:** Decide on production Canoe strategy
6. ⏳ **Pending:** Update smart contracts for ZisK verification
